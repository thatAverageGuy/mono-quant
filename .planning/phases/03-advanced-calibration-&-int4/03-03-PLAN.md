---
phase: 03-advanced-calibration-&-int4
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/mono_quant/core/observers.py
  - src/mono_quant/core/quantizers.py
  - src/mono_quant/io/validation.py
  - src/mono_quant/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can skip sensitive layers (embeddings, normalization) during INT4 quantization"
    - "System provides default INT4 skip list (Embedding, LayerNorm, BatchNorm, small layers)"
    - "Accuracy warning system warns when SQNR is low or all layers were quantized"
    - "Warnings are configurable (error/warn/ignore) for CI/CD compatibility"
    - "Layer skipping API supports type-based, name-based, and unified modules_to_not_convert parameter"
    - "QuantizationInfo includes warnings list for user inspection"
  artifacts:
    - path: "src/mono_quant/core/observers.py"
      provides: "Layer skipping functions with default INT4 skip list"
      min_lines: 50
      exports: ["DEFAULT_INT4_SKIP", "_get_layers_to_skip"]
    - path: "src/mono_quant/core/quantizers.py"
      provides: "Extended static_quantize with layer skipping for INT4"
      contains: "modules_to_not_convert|skip_layer_types|skip_layer_names"
    - path: "src/mono_quant/io/validation.py"
      provides: "Accuracy warning check function with configurable thresholds"
      min_lines: 80
      exports: ["check_accuracy_warnings"]
    - path: "src/mono_quant/__init__.py"
      provides: "Public API exports for accuracy warnings"
      contains: "check_accuracy_warnings"
  key_links:
    - from: "src/mono_quant/core/quantizers.py"
      to: "src/mono_quant/core/observers.py"
      via: "static_quantize uses _get_layers_to_skip for unified layer skipping"
      pattern: "_get_layers_to_skip"
    - from: "src/mono_quant/io/validation.py"
      to: "src/mono_quant/io/validation.py:ValidationResult"
      via: "check_accuracy_warnings populates warnings list in ValidationResult"
      pattern: "warnings.*append|check_accuracy_warnings"
    - from: "src/mono_quant/core/quantizers.py"
      to: "src/mono_quant/io/validation.py"
      via: "static_quantize calls check_accuracy_warnings after quantization"
      pattern: "check_accuracy_warnings"
---

<objective>
Build layer skipping mechanism and accuracy warning system for INT4 quantization. Layer skipping protects sensitive components (embeddings, normalization layers) from aggressive INT4 quantization. Accuracy warnings alert users when quantization quality metrics indicate potential accuracy loss.

Purpose: INT4 quantization is aggressive and can significantly impact model accuracy if applied to all layers. Some layer types (embeddings, normalization) are particularly sensitive. Layer skipping allows users to exclude these layers from quantization. Accuracy warnings provide early feedback when SQNR is low or quantization is too aggressive, helping users avoid accuracy degradation.

Output: Default INT4 skip list, unified layer skipping API (modules_to_not_convert, skip_layer_types, skip_layer_names), accuracy warning check function with SQNR thresholds, extended QuantizationInfo with warnings field, and static_quantize integration with layer skipping for INT4.
</objective>

<execution_context>
@C:\Users\ghost\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\ghost\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-advanced-calibration-&-int4/03-CONTEXT.md
@.planning/phases/03-advanced-calibration-&-int4/03-RESEARCH.md
@.planning/phases/02-static-quantization-&-i/02-02-SUMMARY.md
@.planning/phases/02-static-quantization-&-i/02-04-SUMMARY.md

# Context from Phase 1-2
- Existing: src/mono_quant/core/observers.py (_select_layers_by_type, _select_layers_by_name, _merge_selection_results)
- Existing: src/mono_quant/core/quantizers.py (static_quantize, QuantizationInfo)
- Existing: src/mono_quant/io/validation.py (ValidationResult, validate_quantization)
- Pattern: Layer selection via type/name filtering
- Pattern: on_failure parameter for configurable error handling (error/warn/ignore)

# Key Implementation Notes from CONTEXT.md and RESEARCH.md
- Default INT4 skip list:
  - Embedding layers (nn.Embedding, nn.EmbeddingBag)
  - Normalization layers (nn.LayerNorm, nn.BatchNorm1d, nn.BatchNorm2d)
  - Layers < 512 parameters (overhead outweighs compression benefit)
- Unified API: modules_to_not_convert as primary parameter
- SQNR thresholds: <10 dB (error), <20 dB (warn), >30 dB (good)
- Warning if all layers were quantized (aggressive quantization)
- CI/CD compatibility: warnings shouldn't break automated pipelines
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create default INT4 skip list and unified layer skipping</name>
  <files>src/mono_quant/core/observers.py</files>
  <action>
Add default INT4 skip list and unified layer skipping function to src/mono_quant/core/observers.py:

1. Define DEFAULT_INT4_SKIP constant (module level, after imports)

   DEFAULT_INT4_SKIP: Dict[str, Any] = {
       "skip_types": (nn.Embedding, nn.EmbeddingBag, nn.LayerNorm, nn.BatchNorm1d, nn.BatchNorm2d),
       "skip_param_threshold": 512,  # Skip layers with fewer parameters
       "skip_names": ["lm_head"],  # Common sensitive output layer
   }

2. _get_layers_to_skip(
     model: nn.Module,
     modules_to_not_convert: Optional[List[str]] = None,
     skip_layer_types: Optional[LayerTypes] = None,
     skip_layer_names: Optional[List[str]] = None,
     skip_param_threshold: int = 0,
   ) -> set

   Implementation:
   - Initialize skip_set = set(modules_to_not_convert or [])
   - Add type-based skips if skip_layer_types provided:
     - Normalize to tuple if single type
     - Iterate through model.named_modules()
     - Add matching module names to skip_set
   - Add name-based skips if skip_layer_names provided:
     - skip_set.update(skip_layer_names)
   - Add small layer skips if skip_param_threshold > 0:
     - Iterate through model.named_modules()
     - Count parameters: param_count = sum(p.numel() for p in module.parameters())
     - Add to skip_set if param_count < skip_param_threshold
   - Return skip_set

3. Add module-level docstring update

   Explain:
   - DEFAULT_INT4_SKIP contains recommended skip list for INT4
   - _get_layers_to_skip provides unified layer skipping API
   - Combines type-based, name-based, and parameter-threshold filtering

Add comprehensive docstrings explaining:
- Default skip list is per RESEARCH.md recommendations
- Unified API accepts multiple input formats for flexibility
- Parameter threshold prevents quantizing tiny layers where overhead > benefit
</action>
  <verify>
import torch.nn as nn
from mono_quant.core.observers import DEFAULT_INT4_SKIP, _get_layers_to_skip

# Test DEFAULT_INT4_SKIP structure
assert "skip_types" in DEFAULT_INT4_SKIP
assert "skip_param_threshold" in DEFAULT_INT4_SKIP
assert DEFAULT_INT4_SKIP["skip_param_threshold"] == 512

# Test _get_layers_to_skip with different inputs
model = nn.Sequential(
    nn.Linear(10, 20),
    nn.LayerNorm(20),
    nn.Linear(20, 5),
)

# Test modules_to_not_convert
skip1 = _get_layers_to_skip(model, modules_to_not_convert=["1"])
assert "1" in skip1

# Test skip_layer_types
skip2 = _get_layers_to_skip(model, skip_layer_types=(nn.LayerNorm,))
assert "1" in skip2  # LayerNorm at index 1

# Test skip_param_threshold
skip3 = _get_layers_to_skip(model, skip_param_threshold=100)
# Should skip layers with <100 parameters
</verify>
  <done>
Default INT4 skip list defined with embeddings, normalization layers, and parameter threshold. Unified _get_layers_to_skip function combines type-based, name-based, and threshold filtering into single skip set for flexible layer exclusion.
</done>
</task>

<task type="auto">
  <name>Task 2: Extend static_quantize with layer skipping for INT4</name>
  <files>src/mono_quant/core/quantizers.py</files>
  <action>
Update static_quantize function in src/mono_quant/core/quantizers.py to support INT4 layer skipping:

1. Add new parameters to static_quantize:

   - modules_to_not_convert: Optional[List[str]] = None (unified skip list, primary parameter)
   - skip_layer_types: Optional[LayerTypes] = None (type-based skips)
   - skip_layer_names: Optional[List[str]] = None (name-based skips)
   - skip_param_threshold: int = 0 (parameter count threshold)
   - group_size: int = 128 (for INT4 quantization)

2. Import layer skipping function:

   - Local import: from mono_quant.core.observers import _get_layers_to_skip, DEFAULT_INT4_SKIP

3. Add INT4-specific layer skipping logic:

   After existing layer selection logic, add:

   - Check if dtype indicates INT4 (bits==4 or group_size specified)
   - For INT4, apply default skip list if no explicit skips provided:
     - If modules_to_not_convert is None and skip_layer_types is None:
       - Apply DEFAULT_INT4_SKIP:
         - skip_layer_types = DEFAULT_INT4_SKIP["skip_types"]
         - skip_param_threshold = DEFAULT_INT4_SKIP["skip_param_threshold"]
         - modules_to_not_convert = DEFAULT_INT4_SKIP["skip_names"].copy()

   - Build unified skip set using _get_layers_to_skip:
     - skip_set = _get_layers_to_skip(
         model_copy,
         modules_to_not_convert=modules_to_not_convert,
         skip_layer_types=skip_layer_types,
         skip_layer_names=skip_layer_names,
         skip_param_threshold=skip_param_threshold,
       )

   - Merge skip_set with skipped_layers from type/name selection:
     - skipped_layers.extend(sorted(skip_set - set(selected_layers)))
     - Remove skipped layers from selected_layers:
       - selected_layers = [l for l in selected_layers if l not in skip_set]

4. Update function docstring

   Document new parameters:
   - modules_to_not_convert: Unified skip list (HuggingFace compatible API)
   - skip_layer_types: Layer types to skip
   - skip_layer_names: Layer names to skip
   - skip_param_threshold: Skip layers with fewer parameters
   - group_size: Group size for INT4 quantization
   - INT4 default skip list behavior

5. Note: For INT4 quantization itself (quantize_weight_int4), that's handled in plan 03-01. This task focuses on layer skipping integration.
</action>
  <verify>
import torch.nn as nn
from mono_quant import static_quantize
import torch

# Test INT4 layer skipping with default skip list
model = nn.Sequential(
    nn.Linear(128, 256),
    nn.LayerNorm(256),
    nn.Linear(256, 10),
)
calibration_data = [torch.randn(32, 128) for _ in range(50)]

# With default INT4 skip (LayerNorm should be skipped)
q_model, info = static_quantize(
    model,
    calibration_data,
    dtype=torch.qint8,  # Will be extended to support INT4 in 03-01
    layer_types=(nn.Linear,),
)
# After 03-01 integration, this should skip LayerNorm automatically

# Test explicit modules_to_not_convert
q_model2, info2 = static_quantize(
    model,
    calibration_data,
    dtype=torch.qint8,
    modules_to_not_convert=["1"],  # Skip LayerNorm explicitly
)
assert "1" in info2.skipped_layers
</verify>
  <done>
static_quantize extended with unified layer skipping API for INT4. Default INT4 skip list automatically excludes embeddings, normalization layers, and small layers. Users can override with modules_to_not_convert, skip_layer_types, skip_layer_names, or skip_param_threshold parameters.
</done>
</task>

<task type="auto">
  <name>Task 3: Create accuracy warning check function</name>
  <files>src/mono_quant/io/validation.py</files>
  <action>
Add accuracy warning check function to src/mono_quant/io/validation.py:

1. Extend ValidationResult dataclass

   Add new field:
   - warnings: List[str] = field(default_factory=list)

2. check_accuracy_warnings(
     info: "QuantizationInfo",
     sqnr_warning_threshold: float = 20.0,
     sqnr_error_threshold: float = 10.0,
     all_layers_quantized_warning: bool = True,
     low_calibration_warning: bool = True,
     on_failure: str = "warn",
   ) -> "QuantizationInfo"

   Implementation:
   - Create a local errors list (not the same as ValidationResult.errors)
   - Check SQNR if available:
     - If info.sqnr_db < sqnr_error_threshold:
       - info.warnings.append(f"CRITICAL: Very low SQNR ({info.sqnr_db:.2f} dB). Significant accuracy loss likely. Consider INT8 or skipping more layers.")
     - Elif info.sqnr_db < sqnr_warning_threshold:
       - info.warnings.append(f"Warning: Low SQNR ({info.sqnr_db:.2f} dB). Quantization may impact accuracy. Verify with task-specific evaluation.")
   - Check if all layers were quantized:
     - If all_layers_quantized_warning and not info.skipped_layers:
       - info.warnings.append("All layers were quantized. For INT4, consider skipping embeddings and normalization layers to preserve accuracy.")
   - Check calibration sample count:
     - If low_calibration_warning and info.calibration_samples_used < 50:
       - info.warnings.append(f"Low calibration sample count ({info.calibration_samples_used}). Recommend at least 100 samples for reliable calibration.")
   - Handle on_failure parameter:
     - Extract critical warnings (those starting with "CRITICAL:")
     - critical = [w for w in info.warnings if w.startswith("CRITICAL:")]
     - If on_failure == "error" and critical:
       - Raise ValueError("; ".join(critical))
     - Elif on_failure == "warn" and critical:
       - import warnings; warnings.warn("; ".join(critical))
     - on_failure == "ignore": silent
   - Return info

3. Add comprehensive docstring

   Explain:
   - SQNR thresholds based on industry practice (from RESEARCH.md)
   - >30 dB: Excellent, 20-30 dB: Good, 10-20 dB: Warning, <10 dB: Critical
   - all_layers_quantized_warning warns about aggressive INT4
   - low_calibration_warning recommends minimum samples
   - on_failure parameter for CI/CD compatibility
</action>
  <verify>
from mono_quant.io.validation import check_accuracy_warnings
from mono_quant.core.quantizers import QuantizationInfo
import torch

# Test SQNR warnings
info_low = QuantizationInfo(
    selected_layers=["0", "1"],
    skipped_layers=[],
    calibration_samples_used=100,
    dtype=torch.qint8,
    symmetric=False,
    sqnr_db=8.0,  # Below error threshold
)
info_low = check_accuracy_warnings(info_low, on_failure="ignore")
assert any("CRITICAL" in w for w in info_low.warnings)

# Test all layers quantized warning
info_all = QuantizationInfo(
    selected_layers=["0", "1"],
    skipped_layers=[],  # No skipped layers
    calibration_samples_used=100,
    dtype=torch.qint8,
    symmetric=False,
    sqnr_db=25.0,
)
info_all = check_accuracy_warnings(info_all, all_layers_quantized_warning=True, on_failure="ignore")
assert any("All layers" in w for w in info_all.warnings)

# Test low calibration warning
info_low_cal = QuantizationInfo(
    selected_layers=["0"],
    skipped_layers=[],
    calibration_samples_used=30,  # Below 50
    dtype=torch.qint8,
    symmetric=False,
    sqnr_db=30.0,
)
info_low_cal = check_accuracy_warnings(info_low_cal, low_calibration_warning=True, on_failure="ignore")
assert any("sample count" in w.lower() for w in info_low_cal.warnings)

# Test on_failure="error" raises for critical
try:
    info_critical = QuantizationInfo(
        selected_layers=["0"],
        skipped_layers=[],
        calibration_samples_used=100,
        dtype=torch.qint8,
        symmetric=False,
        sqnr_db=5.0,
    )
    check_accuracy_warnings(info_critical, on_failure="error")
    assert False, "Should raise ValueError"
except ValueError as e:
    assert "CRITICAL" in str(e)
</verify>
  <done>
check_accuracy_warnings function warns users about potential accuracy issues. Checks SQNR thresholds (error <10 dB, warn <20 dB), all-layers-quantized condition, and low calibration sample count. Configurable on_failure parameter (error/warn/ignore) for CI/CD compatibility.
</done>
</task>

<task type="auto">
  <name>Task 4: Extend QuantizationInfo with warnings field</name>
  <files>src/mono_quant/core/quantizers.py</files>
  <action>
Update QuantizationInfo dataclass in src/mono_quant/core/quantizers.py:

1. Add warnings field to QuantizationInfo:

   @dataclass
   class QuantizationInfo:
       # ... existing fields ...
       warnings: List[str] = field(default_factory=list)

2. Update QuantizationInfo docstring

   Document the new warnings field:
   - List of warning messages about potential accuracy issues
   - Populated by check_accuracy_warnings function
   - Empty if no warnings

3. Note: ValidationResult in io/validation.py already has warnings field from Task 3. This task ensures QuantizationInfo also tracks warnings for consistency.

Add docstring explaining warnings field and how it's populated.
</action>
  <verify>
from mono_quant.core.quantizers import QuantizationInfo

# Test QuantizationInfo with warnings
info = QuantizationInfo(
    selected_layers=["0"],
    skipped_layers=[],
    calibration_samples_used=100,
    dtype=torch.qint8,
    symmetric=False,
    warnings=["Test warning message"],
)
assert len(info.warnings) == 1
assert "Test warning" in info.warnings[0]

# Test default empty list
info2 = QuantizationInfo(
    selected_layers=["0"],
    skipped_layers=[],
    calibration_samples_used=100,
    dtype=torch.qint8,
    symmetric=False,
)
assert info2.warnings == []
</verify>
  <done>
QuantizationInfo extended with warnings field for tracking accuracy-related warning messages. Warnings list is empty by default and populated by check_accuracy_warnings function.
</done>
</task>

<task type="auto">
  <name>Task 5: Integrate accuracy warnings with static_quantize</name>
  <files>src/mono_quant/core/quantizers.py</files>
  <action>
Integrate accuracy warning check into static_quantize function in src/mono_quant/core/quantizers.py:

1. Add new parameters to static_quantize:

   - accuracy_warning: str = "warn" (how to handle warnings: "error", "warn", "ignore")
   - sqnr_warning_threshold: float = 20.0
   - sqnr_error_threshold: float = 10.0

2. Import check_accuracy_warnings:

   - Local import: from mono_quant.io.validation import check_accuracy_warnings

3. Add accuracy warning check after validation:

   After the existing validation section (after _run_validation_and_update_info), add:

   - Run accuracy warning check:
     - info = check_accuracy_warnings(
         info,
         sqnr_warning_threshold=sqnr_warning_threshold,
         sqnr_error_threshold=sqnr_error_threshold,
         all_layers_quantized_warning=True,
         low_calibration_warning=True,
         on_failure=accuracy_warning,
       )

4. Update function docstring

   Document new parameters:
   - accuracy_warning: How to handle accuracy warnings ("error", "warn", "ignore")
   - sqnr_warning_threshold: SQNR below this triggers warning (dB)
   - sqnr_error_threshold: SQNR below this triggers error (dB)

   Explain:
   - Warnings check for low SQNR, all layers quantized, low calibration count
   - Default "warn" issues warnings but doesn't break execution
   - Use "ignore" for CI/CD pipelines
</action>
  <verify>
# This verification will be tested after 03-01 and 03-02 are complete
# when INT4 quantization is fully available. For now, verify the
# function signature accepts the new parameters.

import inspect
from mono_quant import static_quantize

sig = inspect.signature(static_quantize)
assert "accuracy_warning" in sig.parameters
assert "sqnr_warning_threshold" in sig.parameters
assert "sqnr_error_threshold" in sig.parameters
</verify>
  <done>
static_quantize integrated with accuracy warning system. Users can configure warning behavior via accuracy_warning parameter (error/warn/ignore) and set custom SQNR thresholds. Warnings alert users to potential accuracy issues before deployment.
</done>
</task>

<task type="auto">
  <name>Task 6: Export accuracy warnings from package root</name>
  <files>src/mono_quant/__init__.py</files>
  <action>
Update src/mono_quant/__init__.py to export accuracy warning function:

1. Import check_accuracy_warnings:
   - from mono_quant.io.validation import check_accuracy_warnings

2. Update __all__ list to include:
   - "check_accuracy_warnings"

3. Update module docstring to mention accuracy warnings

This follows the established pattern where validation functions are exported from package root.
</action>
  <verify>
from mono_quant import check_accuracy_warnings

# Verify import works
assert callable(check_accuracy_warnings)

# Check in __all__
from mono_quant import core
import mono_quant
# Note: __all__ might not be defined, which is fine
# Just verify the import works
</verify>
  <done>
check_accuracy_warnings exported from mono_quant package root. Users can directly access accuracy warning checking function for manual invocation or custom workflows.
</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. DEFAULT_INT4_SKIP constant contains recommended skip list for INT4
2. _get_layers_to_skip function combines type/name/threshold filtering
3. static_quantize accepts modules_to_not_convert, skip_layer_types, skip_layer_names, skip_param_threshold
4. Default INT4 skip list automatically applied for INT4 quantization
5. check_accuracy_warnings warns on low SQNR, all layers quantized, low calibration
6. QuantizationInfo has warnings field for tracking warning messages
7. static_quantize integrates accuracy warning check with configurable thresholds
8. on_failure parameter allows "error", "warn", or "ignore" for CI/CD compatibility
9. check_accuracy_warnings exported from package root
</verification>

<success_criteria>
- Layer skipping mechanism protects sensitive components from INT4 quantization
- Default INT4 skip list excludes embeddings, normalization layers, and small layers (<512 params)
- Unified API (modules_to_not_convert) compatible with HuggingFace patterns
- Accuracy warnings alert users to low SQNR (<20 dB warn, <10 dB error)
- Warnings for aggressive quantization (all layers quantized) and low calibration count
- Configurable warning behavior (error/warn/ignore) for CI/CD compatibility
- Warnings tracked in QuantizationInfo for user inspection
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-calibration-&-int4/03-03-SUMMARY.md`
</output>
