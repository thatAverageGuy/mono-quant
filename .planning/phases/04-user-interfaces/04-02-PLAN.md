---
phase: 04-user-interfaces
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/mono_quant/cli/__init__.py
  - src/mono_quant/cli/main.py
  - src/mono_quant/cli/commands.py
  - src/mono_quant/cli/progress.py
  - pyproject.toml
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can quantize via CLI: monoquant quantize --model model.pt --bits 8"
    - "CLI shows progress bar for calibration and quantization operations"
    - "CLI supports both short (-b) and long (--bits) flags"
    - "Default output naming: model_quantized.pt (auto-named from input)"
    - "CLI has --strict flag for error handling configuration"
    - "Subcommands: quantize, validate, info, compare, calibrate"
    - "Entry point registered: monoquant command available after install"
  artifacts:
    - path: "src/mono_quant/cli/main.py"
      provides: "Click CLI app with command groups and version option"
      min_lines: 60
      exports: ["cli"]
    - path: "src/mono_quant/cli/commands.py"
      provides: "CLI subcommands (quantize, validate, info, compare, calibrate)"
      min_lines: 200
      exports: ["quantize_cmd", "validate_cmd", "info_cmd", "compare_cmd", "calibrate_cmd"]
    - path: "src/mono_quant/cli/progress.py"
      provides: "Progress bar utilities for CLI (CI-friendly tqdm wrapper)"
      min_lines: 40
      exports: ["progress_context", "should_show_progress"]
    - path: "pyproject.toml"
      provides: "console_scripts entry points for monoquant and mq commands"
      contains: "[project.scripts]"
  key_links:
    - from: "src/mono_quant/cli/commands.py"
      to: "src/mono_quant/api/quantize.py"
      via: "quantize_cmd calls quantize() function"
      pattern: "from mono_quant.api import quantize"
    - from: "src/mono_quant/cli/commands.py"
      to: "src/mono_quant/cli/progress.py"
      via: "Commands use progress_context for long operations"
      pattern: "progress_context"
    - from: "src/mono_quant/cli/main.py"
      to: "src/mono_quant/cli/commands.py"
      via: "cli group registers subcommands"
      pattern: "cli.command|cli.group"
---

<objective>
Build a command-line interface using Click with subcommands for quantize, validate, info, compare, and calibrate operations. The CLI provides git-style command structure, progress bars using tqdm, and both short and long flag options. Entry points are registered for monoquant and mq commands.

Purpose: Enable CI/CD integration and command-line workflows for model quantization. The CLI wraps the Python API from plan 04-01, providing a familiar command-line interface for automation and quick operations.

Output: Click-based CLI with subcommands, progress bar wrapper for CI-friendly output, console_scripts entry points for monoquant/mq commands, and help text with examples.
</objective>

<execution_context>
@C:\Users\ghost\.thatAverageGuy\get-shit-done\workflows\execute-plan.md
@C:\Users\ghost\.thatAverageGuy\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-user-interfaces/04-CONTEXT.md
@.planning/phases/04-user-interfaces/04-RESEARCH.md
@.planning/phases/04-user-interfaces/04-01-PLAN.md

# Dependencies from 04-01
- src/mono_quant/api/quantize.py: unified quantize() function
- src/mono_quant/api/result.py: QuantizationResult with .save() method
- src/mono_quant/io/__init__.py: save_model(), load_model()
- src/mono_quant/io/validation.py: validate_quantization(), ValidationResult

# Key Implementation Notes from CONTEXT.md (LOCKED)
- Subcommand pattern: monoquant quantize --model model.pt --bits 8
- Flag naming: Both short and long flags (-b/--bits, -m/--model, -s/--scheme)
- Output naming: Default auto-naming (model_quantized.pt) with --output flag
- Command set: quantize, validate, info, compare, calibrate
- CLI name: monoquant (primary), mq (alias)
- --strict flag for error behavior (default: warn, --strict: exit immediately)

# Key Implementation Notes from RESEARCH.md
- Click 8.1+ for CLI framework (@click.group, @click.command decorators)
- tqdm for progress bars with CI/CD friendly disable logic
- console_scripts in pyproject.toml for entry point registration
- Error codes: 0=success, 1=general, 2=config, 3=quantization, 4=validation, 5=I/O
- Use click.Context.exit() or click.ClickException for proper CLI behavior

# Decisions from Context (LOCKED)
- Progress library: tqdm (minimal deps, CI-friendly)
- When to show progress: Always for calibration and quantization (no threshold)
- Progress bar CI/CD disable: Check CI env var or TTY detection
- Python API progress: show_progress parameter (from 04-01)
- CLI progress: Always show progress (unless disabled by CI/TTY detection)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create progress bar utilities for CLI</name>
  <files>src/mono_quant/cli/progress.py</files>
  <action>
Create src/mono_quant/cli/progress.py with progress bar utilities:

1. should_show_progress() -> bool function:
   - Import os, sys
   - Check if CI env var is set (os.getenv('CI')): return False if set
   - Check if stdout is TTY: hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()
   - Return True if TTY, False otherwise

2. progress_context(context_manager) decorator/context manager:
   - Wrapper around tqdm that disables based on should_show_progress()
   - Import tqdm from tqdm
   - Returns tqdm with disable=not should_show_progress()

3. cli_progress iterable wrapper:
   def cli_progress(iterable, desc: str = "", **kwargs):
       from tqdm import tqdm
       return tqdm(iterable, desc=desc, disable=not should_show_progress(), **kwargs)

Add docstrings explaining CI/CD compatibility and TTY detection.
</action>
  <verify>
from mono_quant.cli.progress import should_show_progress, cli_progress
import time

# Test TTY detection (result depends on environment)
result = should_show_progress()
assert isinstance(result, bool)

# Test cli_progress wrapper (won't actually show progress in test)
items = list(range(5))
for item in cli_progress(items, desc="Test"):
    pass  # Just iterate
assert items is not None
</verify>
  <done>
Progress bar utilities created with should_show_progress() for CI/TTY detection and cli_progress() wrapper for tqdm. Disables progress bars automatically in CI environments (CI env var set) or non-TTY output.
</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI main module with Click group</name>
  <files>src/mono_quant/cli/main.py</files>
  <action>
Create src/mono_quant/cli/main.py with Click CLI structure:

1. Import click and subcommands:
   import click
   from .commands import (
       quantize_cmd,
       validate_cmd,
       info_cmd,
       compare_cmd,
       calibrate_cmd,
   )

2. Create Click group:
   @click.group()
   @click.version_option(version="0.1.0", prog_name="monoquant")
   @click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
   @click.pass_context
   def cli(ctx, verbose):
       """Mono Quant - Simple, reliable model quantization.

       For detailed help on each command, run:
         monoquant COMMAND --help
       """
       ctx.ensure_object(dict)
       ctx.obj['verbose'] = verbose

3. Register subcommands:
   cli.add_command(quantize_cmd)
   cli.add_command(validate_cmd)
   cli.add_command(info_cmd)
   cli.add_command(compare_cmd)
   cli.add_command(calibrate_cmd)

4. Export cli:
   __all__ = ["cli"]

5. Add if __name__ == '__main__': cli() for direct execution

Add comprehensive module docstring with CLI usage examples.
</action>
  <verify>
from mono_quant.cli.main import cli
import click

# Verify cli is a Click group
assert isinstance(cli, click.Group)

# Verify version option is registered
# This tests the Click structure is valid
assert cli.name == "cli"
</verify>
  <done>
CLI main module created with Click group, version option, and verbose flag. Subcommands are registered as separate commands. Module can be executed directly for testing.
</done>
</task>

<task type="auto">
  <name>Task 3: Create CLI subcommands</name>
  <files>src/mono_quant/cli/commands.py</files>
  <action>
Create src/mono_quant/cli/commands.py with all subcommands:

1. quantize_cmd command:
   @cli.command(name="quantize")
   @click.option('--model', '-m', 'model_path', required=True,
                 type=click.Path(exists=True), help='Path to input model (.pt, .pth, .safetensors)')
   @click.option('--bits', '-b', default=8, type=click.IntRange(4, 16),
                 help='Quantization bits (4, 8, or 16 for FP16). Default: 8')
   @click.option('--output', '-o', 'output_path', type=click.Path(),
                 help='Output path (default: <input>_quantized.<ext>)')
   @click.option('--scheme', '-s', type=click.Choice(['symmetric', 'asymmetric']),
                 default='symmetric', help='Quantization scheme. Default: symmetric')
   @click.option('--dynamic/--static', 'dynamic', default=False,
                 help='Use dynamic quantization (no calibration needed)')
   @click.option('--calibration', '-c', type=click.Path(exists=True),
                 help='Calibration data file (for static quantization)')
   @click.option('--strict', is_flag=True,
                 help='Exit immediately on any error (default: warn and continue)')
   @click.pass_obj
   def quantize_cmd(obj, model_path, bits, output_path, scheme, dynamic, calibration, strict):
       """Quantize a PyTorch model to specified precision.

       Examples:
         # Dynamic quantization (simple, no calibration)
         monoquant quantize --model model.pt --bits 8 --dynamic

         # Static quantization with calibration
         monoquant quantize -m model.pt -b 8 -c calib_data.pt

         # INT4 quantization with symmetric scheme
         monoquant quantize --model model.pt --bits 4 --scheme symmetric
       """
       from mono_quant.api import quantize
       from mono_quant.io import load_model
       from mono_quant.cli.progress import should_show_progress
       import click

       click.echo(f"Loading model: {model_path}")

       try:
           state_dict = load_model(model_path)
           # Note: For state_dict input, user needs to provide model architecture
           # For simplicity, this assumes state_dict can be used with _prepare_model

           if dynamic:
               result = quantize(
                   state_dict,
                   bits=bits,
                   dynamic=True,
                   scheme=scheme,
                   show_progress=should_show_progress()
               )
           else:
               if not calibration:
                   raise click.ClickException(
                       "Calibration data required for static quantization. "
                       "Use --dynamic flag or provide --calibration file."
                   )
               # Load calibration data (placeholder - actual implementation would load from file)
               raise click.ClickException(
                   "Calibration file loading not yet implemented. "
                   "Use Python API with calibration_data parameter."
               )

           if not result.success:
               for error in result.errors:
                   click.echo(f"Error: {error}", err=True)
               if strict:
                   raise click.ClickException("Quantization failed")

           # Determine output path
           if output_path is None:
               input_name = click.Path(model_path).stem
               output_path = f"{input_name}_quantized.pt"

           # Save result
           result.save(str(output_path))
           click.echo(f"Saved quantized model to: {output_path}")

           # Show metrics
           if result.info.sqnr_db is not None:
               click.echo(f"SQNR: {result.info.sqnr_db:.2f} dB")
           if result.info.compression_ratio is not None:
               click.echo(f"Compression: {result.info.compression_ratio:.2f}x")

       except Exception as e:
           click.echo(f"Error: {e}", err=True)
           raise click.ClickException(str(e))

2. validate_cmd command:
   @cli.command()
   @click.argument('model_path', type=click.Path(exists=True))
   @click.option('--strict', is_flag=True, help='Exit on validation failure')
   def validate(model_path, strict):
       """Validate a quantized model.

       Example:
         monoquant validate quantized_model.pt
       """
       from mono_quant.io import load_model
       from mono_quant.io.validation import validate_quantization
       click.echo(f"Validating {model_path}...")
       # Load and validate
       click.echo("Validation complete")

3. info_cmd command:
   @cli.command()
   @click.argument('model_path', type=click.Path(exists=True))
   @click.option('--format', '-f', type=click.Choice(['json', 'text']), default='text',
                 help='Output format')
   def info(model_path, format):
       """Display information about a quantized model.

       Example:
         monoquant info quantized_model.pt
         monoquant info quantized_model.pt --format json
       """
       click.echo(f"Model info for: {model_path}")
       # Display metadata

4. compare_cmd command:
   @cli.command()
   @click.argument('original_path', type=click.Path(exists=True))
   @click.argument('quantized_path', type=click.Path(exists=True))
   @click.option('--metrics', '-m', multiple=True,
                 type=click.Choice(['sqnr', 'size', 'all']), default=['all'],
                 help='Metrics to compare')
   def compare(original_path, quantized_path, metrics):
       """Compare original and quantized models.

       Example:
         monoquant compare model.pt quantized_model.pt
       """
       click.echo(f"Comparing {original_path} vs {quantized_path}")
       # Comparison logic

5. calibrate_cmd command:
   @cli.command()
   @click.argument('model_path', type=click.Path(exists=True))
   @click.argument('data_path', type=click.Path(exists=True))
   @click.option('--output', '-o', type=click.Path(), help='Output calibration file')
   @click.option('--samples', '-n', type=int, default=150, help='Number of samples')
   def calibrate(model_path, data_path, output, samples):
       """Run calibration on a model and save calibration data.

       Example:
         monoquant calibrate model.pt calibration_data.pt --samples 200
       """
       click.echo(f"Calibrating {model_path} with {samples} samples")
       # Calibration logic

Export all commands: __all__ = ["quantize_cmd", "validate_cmd", "info_cmd", "compare_cmd", "calibrate_cmd"]
</action>
  <verify>
from mono_quant.cli.commands import (
    quantize_cmd,
    validate_cmd,
    info_cmd,
    compare_cmd,
    calibrate_cmd,
)
import click

# Verify all commands are Click commands
assert isinstance(quantize_cmd, click.Command)
assert isinstance(validate_cmd, click.Command)
assert isinstance(info_cmd, click.Command)
assert isinstance(compare_cmd, click.Command)
assert isinstance(calibrate_cmd, click.Command)

# Verify command names
assert quantize_cmd.name == "quantize"
assert validate_cmd.name == "validate"
</verify>
  <done>
CLI subcommands created for quantize, validate, info, compare, and calibrate operations. quantize_cmd uses unified quantize() API, supports all required flags (--model/-m, --bits/-b, --output/-o, --scheme/-s, --dynamic/--static, --calibration/-c, --strict). Help text includes examples for common workflows.
</done>
</task>

<task type="auto">
  <name>Task 4: Register entry points and update package config</name>
  <files>src/mono_quant/cli/__init__.py, pyproject.toml</files>
  <action>
Create src/mono_quant/cli/__init__.py:
1. Import cli from .main: from .main import cli
2. Export in __all__: __all__ = ["cli"]
3. Add module docstring

Update pyproject.toml:
1. Add Click to dependencies:
   dependencies = [
       "torch>=2.0.0",
       "safetensors>=0.4",
       "tqdm>=4.66",
       "click>=8.1",
   ]

2. Add [project.scripts] section:
   [project.scripts]
   monoquant = "mono_quant.cli.main:cli"
   mq = "mono_quant.cli.main:cli"

3. Update version in Click command if needed (currently hardcoded to "0.1.0")

This registers both monoquant and mq commands as console_scripts entry points, available after pip install.
</action>
  <verify>
# Test CLI module imports
from mono_quant.cli import cli
from mono_quant.cli.main import cli as cli_main

# Verify same object
assert cli is cli_main

# Check pyproject.toml has entry points
import tomli
with open("pyproject.toml", "rb") as f:
    data = tomli.load(f)
    scripts = data.get("project", {}).get("scripts", {})
    assert "monoquant" in scripts
    assert "mq" in scripts
    assert scripts["monoquant"] == "mono_quant.cli.main:cli"

# Verify Click dependency
deps = data["project"]["dependencies"]
assert any("click" in dep for dep in deps)
</verify>
  <done>
CLI module exports cli group. pyproject.toml updated with Click dependency and console_scripts entry points for both monoquant and mq commands. Commands will be available after pip install -e . or pip install mono-quant.
</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. from mono_quant.cli import cli - imports successfully
2. monoquant --help shows all subcommands (quantize, validate, info, compare, calibrate)
3. monoquant quantize --help shows all required flags with short/long options
4. Progress bars show in TTY, disable in CI (CI env var set)
5. console_scripts entry points registered in pyproject.toml
6. Click added to dependencies
7. quantize_cmd uses unified quantize() API from 04-01
8. All commands have help text with examples
</verification>

<success_criteria>
- monoquant command available after pip install (or pip install -e . for dev)
- monoquant quantize --model model.pt --bits 8 --dynamic quantizes model
- CLI shows progress bars during calibration/quantization
- Progress bars auto-disable in CI environments (CI=1)
- Both short (-b) and long (--bits) flags work
- Default output naming: model_quantized.pt
- mq alias works as alternative to monoquant
- --strict flag causes immediate exit on errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-interfaces/04-02-SUMMARY.md`
</output>
